#!/usr/bin/env python

import argparse
import os
import sys
from multiprocessing.pool import ThreadPool
from threading import Lock

parser = argparse.ArgumentParser(description="process and geocode business registries")

parser.add_argument(
    "--year", "-y", type=int, required=True, help="""
        The year of the registry.""")
parser.add_argument(
    "--images", "-i", required=True, nargs='+', help="""
        Images to process.""")
parser.add_argument(
    "--threads", type=int, default = 1, help="""
        Number of threads to use.""")
parser.add_argument(
    "--append", action="store_true", help="""
        Append to the output file instead of overwriting it.""")
parser.add_argument(
    "--debug", action="store_true", help="""
        Draw images showing intermediate output during processing.""")
parser.add_argument(
    "--pre-processed", action="store_true", help="""
        Assume images have been preprocessed by scan-tailor.""")
parser.add_argument(
    "--outdir", "-o", required=True, help="""
        Path to the directory to write out results.""")
parser.add_argument(
    "--state", "-s", default="", required=True, help="""
        US state to get city list.""")

args = parser.parse_args()

# import registry processor based on year
if args.state == 'RI':
    if args.year > 1975:
        from georeg.registry_processor_ri import RegistryProcessorNew as RegistryProcessor
    else:
        from georeg.registry_processor_ri import RegistryProcessorOld as RegistryProcessor
elif args.state == 'TX':
    if args.year == 2005 or args.year == 2011 or args.year == 2010:
        from georeg.registry_processor_tx import RegistryProcessor2000s as RegistryProcessor
    elif args.year == 1999:
        from georeg.registry_processor_tx import RegistryProcessor1999 as RegistryProcessor
    elif args.year == 1995:
        from georeg.registry_processor_tx import RegistryProcessor1995 as RegistryProcessor
    elif args.year == 1990:
        from georeg.registry_processor_tx import RegistryProcessor1990 as RegistryProcessor
    elif args.year == 1980 or args.year == 1985:
        from georeg.registry_processor_tx import RegistryProcessor1980s as RegistryProcessor
    elif args.year == 1975:
        from georeg.registry_processor_tx import RegistryProcessor1975 as RegistryProcessor
    elif args.year in [1965, 1970]:
        from georeg.registry_processor_tx import RegistryProcessor1965 as RegistryProcessor
    elif args.year == 1960:
        from georeg.registry_processor_tx import RegistryProcessor1960 as RegistryProcessor
    elif args.year == 1950 or args.year == 1954:
        from georeg.registry_processor_tx import RegistryProcessor1950s as RegistryProcessor
    else:
        raise ValueError("%d is not a supported year for TX" % (args.year,))

else:
    raise ValueError("%s is not a supported state" % (args.state,))

reg_processor = RegistryProcessor()
reg_processor.initialize_state_year(args.state, args.year)

reg_processor.draw_debug_images = args.debug
reg_processor.assume_pre_processed = args.pre_processed
reg_processor.debugdir = args.outdir

outname = "%s/%d-compiled.tsv" % (args.outdir, args.year)

# truncate file if we aren't suppose to append
if not args.append:
    f = open(outname, 'w')
    f.close()

images_per_thread = len(args.images) / args.threads

pool = ThreadPool(processes=args.threads)

out_file_mutex = Lock()

def worker_thread_proc(*args):

    # local copy of reg_processor that we can use in this thread
    _reg_processor = RegistryProcessor(reg_processor)
    images = args

    for image in images:
        print >> sys.stderr, "processing:", image
        _reg_processor.process_image(image)

        # access to file must be syncronized
        out_file_mutex.acquire()
        _reg_processor.record_to_tsv(outname, 'a')
        out_file_mutex.release()

for i in xrange(args.threads):
    assigned_images = []

    if i == args.threads - 1:
        assigned_images = args.images[i*images_per_thread:]
    else:
        assigned_images = args.images[i * images_per_thread:(i + 1) * images_per_thread]

    # we aren't expecting any return values so no need to store results
    pool.apply_async(worker_thread_proc, args = assigned_images)

pool.close()
pool.join()

print('\a')  #makes a noise at the end of the script.  May only work on Mac
print >>sys.stderr, "done"

#!/usr/bin/env python

import argparse
import os
import sys
import traceback
import fnmatch
import copy
import time
import multiprocessing
from multiprocessing import Lock, Queue
from multiprocessing.pool import ThreadPool

parser = argparse.ArgumentParser(description="process and geocode business registries")

parser.add_argument(
    "--year", "-y", type=int, required=True, help="""
        The year of the registry.""")
parser.add_argument(
    "--images", "-i", required=True, help="""
        Path of images to process (not a list, use unix file matching).""")
parser.add_argument(
    "--append", action="store_true", help="""
        Append to the output file instead of overwriting it.""")
parser.add_argument(
    "--debug", action="store_true", help="""
        Draw images showing intermediate output during processing.""")
parser.add_argument(
    "--pre-processed", action="store_true", help="""
        Assume images have been preprocessed by scan-tailor.""")
parser.add_argument(
    "--outdir", "-o", required=True, help="""
        Path to the directory to write out results.""")
parser.add_argument(
    "--state", "-s", default="", required=True, help="""
        US state to get city list.""")

args = parser.parse_args()

# import registry processor based on year
if args.state == 'RI':
    if args.year > 1975:
        from georeg.registry_processor_ri import RegistryProcessorNew as RegistryProcessor
    else:
        from georeg.registry_processor_ri import RegistryProcessorOld as RegistryProcessor
elif args.state == 'TX':
    if args.year == 2005 or args.year == 2011 or args.year == 2010:
        from georeg.registry_processor_tx import RegistryProcessor2000s as RegistryProcessor
    elif args.year == 1999:
        from georeg.registry_processor_tx import RegistryProcessor1999 as RegistryProcessor
    elif args.year == 1995:
        from georeg.registry_processor_tx import RegistryProcessor1995 as RegistryProcessor
    elif args.year == 1990:
        from georeg.registry_processor_tx import RegistryProcessor1990 as RegistryProcessor
    elif args.year == 1980 or args.year == 1985:
        from georeg.registry_processor_tx import RegistryProcessor1980s as RegistryProcessor
    elif args.year == 1975:
        from georeg.registry_processor_tx import RegistryProcessor1975 as RegistryProcessor
    elif args.year in [1965, 1970]:
        from georeg.registry_processor_tx import RegistryProcessor1965 as RegistryProcessor
    elif args.year == 1960:
        from georeg.registry_processor_tx import RegistryProcessor1960 as RegistryProcessor
    elif args.year == 1950 or args.year == 1954:
        from georeg.registry_processor_tx import RegistryProcessor1950s as RegistryProcessor
    else:
        raise ValueError("%d is not a supported year for TX" % (args.year))

else:
    raise ValueError("%s is not a supported state" % (args.state))

reg_processor = RegistryProcessor()
reg_processor.initialize_state_year(args.state, args.year)

reg_processor.draw_debug_images = args.debug
reg_processor.assume_pre_processed = args.pre_processed
reg_processor.debugdir = args.outdir

outname = "%s/%d-compiled.tsv" % (args.outdir, args.year)

def worker_thread_f(images):
    try:
        # local copy of reg_processor that we can use in this thread
        _reg_processor = copy.copy(reg_processor)
        _reg_processor.remake_tmp_file_path()

        for image in images:
            print "processing:", image

            _reg_processor.process_image(image)

            # access to file must be syncronized
            worker_thread_f.file_mutex.acquire()
            _reg_processor.record_to_tsv(outname, 'a')
            worker_thread_f.file_mutex.release()
    except Exception:
        worker_thread_f.bucket.put(sys.exc_info())

# static variables for worker thread function
worker_thread_f.bucket = Queue() # holds exception information of crashed threads
worker_thread_f.file_mutex = Lock()

# truncate file if we aren't suppose to append
if not args.append:
    f = open(outname, 'w')
    f.close()

# construct actual image list from unix file match pattern
dir, pattern = os.path.split(args.images)
image_list = []

for item in os.listdir(dir):
    if fnmatch.fnmatch(item, pattern):
        image_list.append(os.path.join(dir,item))

# find number of cores
try:
    num_threads = multiprocessing.cpu_count()
except NotImplementedError:
    print >>sys.stderr, "unable to detect number of cores... defaulting to 4 threads"
    num_threads = 4

# intialize some threading variables
images_per_thread = len(image_list) / num_threads
pool = ThreadPool(processes = num_threads)
results = []

start_time = time.time()

# start threads
for i in xrange(num_threads):
    assigned_images = []

    if i == num_threads - 1:
        assigned_images = image_list[i * images_per_thread:]
    else:
        assigned_images = image_list[i * images_per_thread:(i + 1) * images_per_thread]

    results.append(pool.apply_async(worker_thread_f, (assigned_images,)))

pool.close()
pool.join()

# print exception information of failed threads
while not worker_thread_f.bucket.empty():
    exc_type, exc_value, exc_trace = worker_thread_f.bucket.get(block=False)

    print >> sys.stderr, exc_type, exc_value
    traceback.print_tb(exc_trace, file=sys.stderr)

num_failed_threads = reduce(lambda n, r: n if r.sucessful() else n + 1, results, 0)
end_time = time.time()

print >>sys.stderr, "Number of worker threads failed: %d" % num_failed_threads
print >>sys.stderr, "Elapsed time: %d hours, %d minutes and %d seconds" % (end_time / 60**2, (end_time % 60**2) / 60, (end_time % 60**2) % 60)

print >>sys.stderr, "done"
